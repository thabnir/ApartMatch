# -*- coding: utf-8 -*-
"""Copy of Description-Matching.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kCxTdJkKdkpcxdK9_YbLonQeQg8Ft4SD
"""

import spacy

nlp = spacy.load("en_core_web_sm")

text = "VAST CONDO IN THE COVETED MILE END - Bright, open-plan living spaces. Abundant windows + skylights. 3 bedrooms. Generous kitchen with central island and ample storage. Intimate terrace overlooking Parc St-Michel. Enjoy the neighborhood life: Within walking distance of public transit, the restaurants on St-Laurent Street and the cafés and boutiques of the Mile End. Ideal location for a family: live on a quiet street, just steps away from Parc St-Michel's playgrounds and soccer field. Experience the best of the Mile End!"

doc = nlp(text)

print(type(doc.ents)) #have this vectorized
print(doc.ents)

entity_vectors = []

# Iterate through the named entities in the document
for ent in doc.ents:
    # Check if the entity has a vector (not all entities may have vectors)
    if ent.has_vector:
        entity_vectors.append(ent.vector)

print(entity_vectors)

import spacy
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

# Load spaCy model
nlp = spacy.load("en_core_web_sm")

# Define a list of dictionaries, where each dictionary contains multiple values
list_of_dicts = [
    {"text": "Apple is a tech company", "category": "Technology"},
    {"text": "Banana is a fruit", "category": "Food"},
    {"text": "Microsoft develops software", "category": "Technology"},
]

# User query
user_query = "Apple is a technology giant"

# Process the user query and get its vector
user_doc = nlp(user_query)
user_vector = user_doc.vector

# Create a list to store cosine similarities and updated dictionaries
results = []

# Iterate through the list of dictionaries
for item in list_of_dicts:
    # Concatenate all values in the dictionary into a single string
    concatenated_text = " ".join(item.values())
    # Process the concatenated text and get its vector
    doc = nlp(concatenated_text)
    item_vector = doc.vector

    # Compute cosine similarity between user vector and item vector
    similarity = cosine_similarity([user_vector], [item_vector])[0][0]
    print(similarity)

    # Add similarity score to the dictionary and append to results
    item["similarity"] = similarity
    results.append(item)

results

# Sort the list of dictionaries by similarity in descending order (most to least similar)
sorted_results = sorted(results, key=lambda x: x["similarity"], reverse=True)

# Print the sorted results
for item in sorted_results:
    print(f"Category: {item['category']}, Similarity: {item['similarity']:.4f}")

!pip install sentence-transformers

# Load a pretrained bi-encoder model
from sentence_transformers import SentenceTransformer, util

model = SentenceTransformer('paraphrase-MiniLM-L6-v2')

# The below would be the actual user input (their text description of their ideal home)
user_description = "I'm looking for a spacious, modern house with a large backyard"
example = "VAST CONDO IN THE COVETED MILE END - Bright, open-plan living spaces. Abundant windows + skylights. 3 bedrooms. Generous kitchen with central island and ample storage. Intimate terrace overlooking Parc St-Michel. Enjoy the neighborhood life: Within walking distance of public transit, the restaurants on St-Laurent Street and the cafés and boutiques of the Mile End. Ideal location for a family: live on a quiet street, just steps away from Parc St-Michel's playgrounds and soccer field. Experience the best of the Mile End!"

# The below variable should store the descriptions of all the houses from the website ideally in a dictionary mapping listings to descriptions
# Lopps through 'description' key of each house and add listing-description pairs to dict? (?)
website_descriptions = [
    "Modern 3-bedroom house with spacious living areas and a large backyard",
    "Cozy 2-bedroom cottage with a garden",
    "Contemporary 4-bedroom home with an open floor plan and outdoor space",
]

# Need to adjust this to our data format
# Encode user description
user_emb = model.encode(user_description, convert_to_tensor=True)

# Encode website descriptions
website_embs = model.encode(website_descriptions, convert_to_tensor=True)

# print(type(user_emb)) for testing purposes
# print(user_emb)

"""**Encode**

- Returns a PyTorch Tensor
- Performs tokenization of input text
- Each word is represented as a vector then entire text is vectorized
"""

# Compute cosine similarity scores between user text description and realtor website descriptions for each listing
similarity_scores = util.pytorch_cos_sim(user_emb, website_embs)

# Find closest matching description to user's ideal home
best_match_idx = similarity_scores.argmax().item()
closest_match = website_descriptions[best_match_idx]

print("Closest match:", closest_match)